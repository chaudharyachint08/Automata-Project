{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red51\green153\blue255;\red0\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red0\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title N 2 D FA.rtf}}

\deflang1033\pard\plain\f0\fs24 \cf0 #include<stdlib.h>\cf1\i //N 2 D FA converter
\par \i0\cf0 #include<stdio.h>
\par #define S 10000  \cf1\i //Programmer-"Achint Chaudhary"
\par \i0\cf0 #define A 100
\par \cf2\b struct\b0  node\cf3\b \{\b0\cf2  
\par 		\b int\b0  data\cf3\b ;
\par \b0\cf2 		\b struct\b0  node \cf3\b *\b0\cf2 next\cf3\b ;\b0\cf2 		 \cf3\b \};
\par 
\par \cf2 struct\b0  stat\cf3\b \{
\par \b0\cf2 	\b int\b0  al\cf3\b [\b0\cf2 A\cf3\b ];
\par \b0\cf2 	\b struct\b0  node \cf3\b *\b0\cf2 next\cf3\b ;
\par \};
\par 
\par \cf2 struct\b0  stat hash\cf3\b [\b0\cf2 S\cf3\b ];
\par 
\par \cf2 struct\b0  node \cf3\b *\b0\cf2 state\cf3\b [\b0\cf2 S\cf3\b ][\b0\cf2 A\cf3\b +\b0\cf4 1\cf3\b ],*\b0\cf2 state2\cf3\b [\b0\cf2 S\cf3\b ][\b0\cf2 A\cf3\b ];\b0\cf1\i //initial & final state tables
\par \i0\cf2\b struct\b0  node \cf3\b *\b0\cf2 alp\cf3\b ,*\b0\cf2 closure\cf3\b [\b0\cf2 S\cf3\b ];\b0\cf1\i //alphabet read list & E-closure of each state
\par 
\par \i0\cf2\b int\b0  dfa\cf3\b [\b0\cf2 S\cf3\b ][\b0\cf2 A\cf3\b ],\b0\cf2 tab\cf3\b [\b0\cf2 S\cf3\b ][\b0\cf2 S\cf3\b ];
\par \cf2 int\b0  states\cf3\b ,\b0\cf2 alpha\cf3\b ,\b0\cf2 count\cf3\b ,\b0\cf2 current\cf3\b ,\b0\cf2 f\cf3\b [\b0\cf2 S\cf3\b ],\b0\cf2 r\cf3\b [\b0\cf2 S\cf3\b ],\b0\cf2 c\cf3\b [\b0\cf2 S\cf3\b ],\b0\cf2 final\cf3\b ,\b0\cf2 pass\cf3\b =\b0\cf4 2\cf3\b ,\b0\cf2 chk\cf3\b ,\b0\cf2 r_modify\cf3\b =\b0\cf4 0\cf3\b ,\b0\cf2 trap\cf3\b ;
\par 
\par \cf2 void\b0  initialize\cf3\b ()
\par \{
\par \b0\cf2 	\b int\b0  i\cf3\b ,\b0\cf2 j\cf3\b ;
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 S\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 A\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		\cf3\b \{\b0\cf2  state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]=\b0\cf2 NULL\cf3\b ;
\par \b0\cf2 		  state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]=\b0\cf2 NULL\cf3\b ;
\par \b0\cf2 		  closure\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf2 NULL\cf3\b ;
\par \b0\cf2 		  hash\cf3\b [\b0\cf2 i\cf3\b ].\b0\cf2 next\cf3\b =\b0\cf2 NULL\cf3\b ;\b0\cf2  \cf3\b \}
\par \}
\par 
\par \cf2 void\b0  sort\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b )
\par \{\b0\cf1\i //Selection sort by swapping data values
\par \i0\cf2 	\b int\b0  temp\cf3\b ;
\par \b0\cf2 	\b struct\b0  node \cf3\b *\b0\cf2 q\cf3\b ;
\par \b0\cf2 	\b while\cf3 (\b0\cf2 list\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	\cf3\b \{\b0\cf2 	q\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		\b while\cf3 (\b0\cf2 q\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 		\cf3\b \{\cf2 if\cf3 ((\b0\cf2 q\cf3\b ->\b0\cf2 data\cf3\b )<(\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b ))
\par \b0\cf2 		   \cf3\b \{\b0\cf2 temp\cf3\b =\b0\cf2 q\cf3\b ->\b0\cf2 data\cf3\b ;\b0\cf2  q\cf3\b ->\b0\cf2 data\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b ;\b0\cf2  list\cf3\b ->\b0\cf2 data\cf3\b =\b0\cf2 temp\cf3\b ;\}
\par \b0\cf2 		q\cf3\b =\b0\cf2 q\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		\cf3\b \}\b0\cf2 	list\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2     \cf3\b \}
\par \}
\par 
\par \cf2 int\b0  comp\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b ,\cf2 struct\b0  node \cf3\b *\b0\cf2 list2\cf3\b )
\par \{
\par \b0\cf2 	\b while\cf3 (\b0\cf2 list\cf3\b !=\b0\cf2 NULL\cf3\b &&\b0\cf2 list2\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	\cf3\b \{
\par \b0\cf2 		\b if\cf3 (\b0\cf2  \cf3\b (\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b )==(\b0\cf2 list2\cf3\b ->\b0\cf2 data\cf3\b )\b0\cf2  \cf3\b )
\par \b0\cf2 		  \cf3\b \{
\par \b0\cf2 		  	list\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		  	list2\cf3\b =\b0\cf2 list2\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		  \cf3\b \}
\par \b0\cf2 		\b else
\par \b0 		  \b return\b0  \cf4 1\cf3\b ;
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	\b if\cf3 (\b0\cf2 list\cf3\b ==\b0\cf2 NULL\cf3\b &&\b0\cf2 list2\cf3\b ==\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	  \b return\b0  \cf4 0\cf3\b ;
\par \b0\cf2 	\b return\b0  \cf4 1\cf3\b ;
\par \}
\par 
\par \cf2 int\b0  search\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b )
\par \{
\par \b0\cf2    \b int\b0  i\cf3\b ,\b0\cf2 k\cf3\b ;
\par \b0\cf2    \b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2    \cf3\b \{
\par \b0\cf2    	k\cf3\b =\b0\cf2 comp\cf3\b (\b0\cf2 list\cf3\b ,\b0\cf2 hash\cf3\b [\b0\cf2 i\cf3\b ].\b0\cf2 next\cf3\b );
\par \b0\cf2    	\b if\cf3 (\b0\cf2 k\cf3\b ==\b0\cf4 0\cf3\b )\b0\cf2  \cf3\b \{\b0\cf2   \b return\b0  i\cf3\b ;\}
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    \b return\b0  \cf3\b -\b0\cf4 1\cf3\b ;
\par \}
\par 
\par \cf2 int\b0  fcheck\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b )
\par \{
\par \b0\cf2 	\b while\cf3 (\b0\cf2 list\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	\cf3\b \{
\par \b0\cf2 		\b if\cf3 (\b0\cf2 f\cf3\b [\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b ]==\b0\cf4 1\cf3\b )
\par \b0\cf2 		  \b return\b0  \cf4 1\cf3\b ;
\par \b0\cf2 		  list\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	\b return\b0  \cf4 0\cf3\b ;
\par \}
\par 
\par \cf2 int\b0  check\cf3\b (\cf2 int\b0  i\cf3\b ,\b0\cf2  \b int\b0  j\cf3\b ,\cf2 int\b0  alp\cf3\b )
\par \{\b0\cf1\i //This function is used to check for each empty block in Table
\par \i0\cf2 	\b int\b0  k\cf3\b ,\b0\cf2 a\cf3\b ,\b0\cf2 b\cf3\b ,\b0\cf2 t\cf3\b ;
\par \b0\cf2 	\b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <\b0\cf2 alp\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2    a\cf3\b =\b0\cf2 dfa\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 k\cf3\b ];
\par \b0\cf2 		b\cf3\b =\b0\cf2 dfa\cf3\b [\b0\cf2 j\cf3\b ][\b0\cf2 k\cf3\b ];
\par \b0\cf2 		\b if\cf3 (\b0\cf2 a\cf3\b <\b0\cf2 b\cf3\b )
\par \b0\cf2 		\cf3\b \{\b0\cf2 t\cf3\b =\b0\cf2 a\cf3\b ;\b0\cf2 a\cf3\b =\b0\cf2 b\cf3\b ;\b0\cf2 b\cf3\b =\b0\cf2 t\cf3\b ;\}
\par \b0\cf2 		\b if\cf3 (\b0\cf2 tab\cf3\b [\b0\cf2 a\cf3\b ][\b0\cf2 b\cf3\b ]!=\b0\cf4 0\cf3\b )
\par \b0\cf2 		\cf3\b \{\cf2 return\b0  \cf4 1\cf3\b ;\}\b0\cf2  \cf3\b \}\b0\cf1\i //for loop ends
\par \i0\cf2 	\b return\b0  \cf4 0\cf3\b ;\b0\cf1\i //if no such alphabet exist pair remains empty (0)
\par \i0\cf3\b \}
\par 
\par \cf2 void\b0  add\cf3\b (\cf2 struct\b0  node \cf3\b **\b0\cf2 list\cf3\b ,\cf2 int\b0  num\cf3\b )
\par \{\b0\cf1\i //add at beginning of Linked list
\par \i0\cf2 	\b struct\b0  node \cf3\b *\b0\cf2 temp\cf3\b ;
\par \b0\cf2 	temp\cf3\b =(\cf2 struct\b0  node \cf3\b *)\b0\cf2 malloc\cf3\b (\cf2 sizeof\cf3 (\cf2 struct\b0  node\cf3\b ));
\par \b0\cf2 	temp\cf3\b ->\b0\cf2 data\cf3\b =\b0\cf2 num\cf3\b ;
\par \b0\cf2 	temp\cf3\b ->\b0\cf2 next\cf3\b =*\b0\cf2 list\cf3\b ;
\par \b0\cf2 	\cf3\b *\b0\cf2 list\cf3\b =\b0\cf2 temp\cf3\b ;
\par \}
\par 
\par \cf2 void\b0  dup\cf3\b (\cf2 struct\b0  node \cf3\b **\b0\cf2 list\cf3\b ,\b0\cf2  \b struct\b0  node \cf3\b *\b0\cf2 p\cf3\b )
\par \{\b0\cf1\i //Generates a separate copy of the linked list in **list
\par \i0\cf2 	\b while\cf3 (\b0\cf2 p\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	\cf3\b \{\b0\cf2  add\cf3\b (\b0\cf2 list\cf3\b ,\b0\cf2 p\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2 	   p\cf3\b =\b0\cf2 p\cf3\b ->\b0\cf2 next\cf3\b ;\b0\cf2  \cf3\b \}
\par \}
\par 
\par \cf2 int\b0  read\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b )
\par \{\b0\cf2    \b int\b0  i\cf3\b ;
\par \b0\cf2 	\b if\cf3 (\b0\cf2 list\cf3\b ==\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	\b return\b0  \cf3\b -\b0\cf4 1\cf3\b ;
\par \b0\cf2 	i\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b ;
\par \b0\cf2 	\b return\b0  i\cf3\b ;
\par \}
\par 
\par \cf2 void\b0   dupdel\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b )
\par \{\b0\cf2 	\b struct\b0  node \cf3\b *\b0\cf2 tmp\cf3\b ;
\par \b0\cf2 	\b while\cf3 (\b0\cf2 list\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	\cf3\b \{\b0\cf2 	tmp\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		\b while\cf3 (\b0\cf2 tmp\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 		\cf3\b \{\b0\cf2   \b if\cf3 ((\b0\cf2 tmp\cf3\b ->\b0\cf2 data\cf3\b )==(\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b ))
\par \b0\cf2 			\cf3\b \{\b0\cf2 tmp\cf3\b =\b0\cf2 tmp\cf3\b ->\b0\cf2 next\cf3\b ;\}
\par \b0\cf2 			\b else\b0  \b break\cf3 ;\}
\par \b0\cf2 	    list\cf3\b ->\b0\cf2 next\cf3\b =\b0\cf2 tmp\cf3\b ;
\par \b0\cf2 	    list\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 	\cf3\b \}
\par \}
\par 
\par \cf2 void\b0  print\cf3\b (\cf2 struct\b0  node \cf3\b *\b0\cf2 list\cf3\b )
\par \{\b0\cf2   \b if\cf3 (\b0\cf2 list\cf3\b ==\b0\cf2 NULL\cf3\b )\{\b0\cf2 printf\cf3\b (\cf5 "%c\\n"\cf3 ,-\b0\cf4 19\cf3\b );\b0\cf2  \b return\cf3 ;\}
\par \b0\cf2 	\b while\cf3 (\b0\cf2 list\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	  \cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "S%d "\cf3 ,\b0\cf2 list\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2 	    list\cf3\b =\b0\cf2 list\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 	  \cf3\b \}
\par \b0\cf2 	   puts\cf3\b (\cf5 ""\cf3 );
\par \b0\cf2 	   \b return\cf3 ;
\par \}
\par \b0\cf2 	  
\par \b void\b0  ermvr\cf3\b ()
\par \{\b0\cf2    
\par     \b int\b0  i\cf3\b ,\b0\cf2 j\cf3\b ,\b0\cf2 k\cf3\b ,\b0\cf2 l\cf3\b ,\b0\cf2 num\cf3\b ;
\par \b0\cf2     \b char\b0  more\cf3\b ;
\par \b0\cf2 	fflush\cf3\b (\b0\cf2 stdin\cf3\b );
\par \b0\cf2 	initialize\cf3\b ();
\par \b0\cf2 	printf\cf3\b (\cf5 "Enter the number of states in NFA-%c "\cf3 ,-\b0\cf4 18\cf3\b );
\par \b0\cf2 	scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 states\cf3\b );
\par \b0\cf2 	printf\cf3\b (\cf5 "Enter the number of alphabets in language "\cf3 );
\par \b0\cf2 	scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 alpha\cf3\b );
\par \b0\cf2 	puts\cf3\b (\cf5 "Enter the enteries in the state table of DFA"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2     printf\cf3\b (\cf5 "\\n  << S%d >> :\\n"\cf3 ,\b0\cf2 i\cf3\b );
\par \b0\cf2 	    	\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2         	\cf3\b \{\b0\cf2  \b if\cf3 (\b0\cf2 j\cf3\b !=\b0\cf4 0\cf3\b )\b0\cf2 puts\cf3\b (\cf5 ""\cf3 );
\par \b0\cf2 			  printf\cf3\b (\cf5 "\\ta%d: \\n"\cf3 ,\b0\cf2 j\cf3\b );
\par \b0\cf2 			 printf\cf3\b (\cf5 "add move <S%d,a%d> ? "\cf3 ,\b0\cf2 i\cf3\b ,\b0\cf2 j\cf3\b );
\par \b0\cf2         	  fflush\cf3\b (\b0\cf2 stdin\cf3\b );\b0\cf2 scanf\cf3\b (\cf5 "%c"\cf3 ,&\b0\cf2 more\cf3\b );
\par \b0\cf2 			  \b while\cf3 (\b0\cf2 more\cf3\b ==\b0\cf2 'y'\cf3\b )
\par \b0\cf2 			  \cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "Enter the state "\cf3 );
\par \b0\cf2 			    scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 num\cf3\b );\b0\cf2  
\par 			    add\cf3\b (&\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ],\b0\cf2 num\cf3\b );
\par \b0\cf2 				printf\cf3\b (\cf5 "add more move <S%d,a%d> ? "\cf3 ,\b0\cf2 i\cf3\b ,\b0\cf2 j\cf3\b );
\par \b0\cf2 				fflush\cf3\b (\b0\cf2 stdin\cf3\b );\b0\cf2 scanf\cf3\b (\cf5 "%c"\cf3 ,&\b0\cf2 more\cf3\b );\}\}
\par \b0\cf2 			    add\cf3\b (&\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 alpha\cf3\b ],\b0\cf2 i\cf3\b );
\par \b0\cf2 			printf\cf3\b (\cf5 "\\nadd %c-moves <S%d> ? "\cf3 ,-\b0\cf4 18\cf3\b ,\b0\cf2 i\cf3\b );
\par \b0\cf2 		    fflush\cf3\b (\b0\cf2 stdin\cf3\b );\b0\cf2 scanf\cf3\b (\cf5 "%c"\cf3 ,&\b0\cf2 more\cf3\b );
\par \b0\cf2 		    \b if\cf3 (\b0\cf2 more\cf3\b ==\b0\cf2 'y'\cf3\b )\b0\cf2 c\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 1\cf3\b ;
\par \b0\cf2 		    \b else\b0  c\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 0\cf3\b ;
\par \b0\cf2 			\b while\cf3 (\b0\cf2 more\cf3\b ==\b0\cf2 'y'\cf3\b )
\par \b0\cf2 			\cf3\b \{\b0\cf2    printf\cf3\b (\cf5 "Enter the state "\cf3 );
\par \b0\cf2 			    scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 num\cf3\b );\b0\cf2  
\par 			    add\cf3\b (&\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 alpha\cf3\b ],\b0\cf2 num\cf3\b );
\par \b0\cf2 				printf\cf3\b (\cf5 "add more %c-moves <S%d> ? "\cf3 ,-\b0\cf4 18\cf3\b ,\b0\cf2 i\cf3\b );
\par \b0\cf2 				fflush\cf3\b (\b0\cf2 stdin\cf3\b );\b0\cf2 scanf\cf3\b (\cf5 "%c"\cf3 ,&\b0\cf2 more\cf3\b );\b0\cf2  \cf3\b \}
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     puts\cf3\b (\cf5 "Mark each state as final(1) of non-final(0)"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf2  scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 f\cf3\b [\b0\cf2 i\cf3\b ]);
\par \b0\cf2 	
\par 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <=\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		\cf3\b \{\b0\cf2  sort\cf3\b (\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  dupdel\cf3\b (\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 	
\par 	\cf1\i //printing initial state table
\par \i0\cf2 	puts\cf3\b (\cf5 "\\n---------------------------------------------------------"\cf3 );
\par \b0\cf2 	puts\cf3\b (\cf5 "Input State table"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "\\n  << S%d"\cf3 ,\b0\cf2 i\cf3\b );
\par \b0\cf2 	  \b if\cf3 (\b0\cf2 f\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 puts\cf3\b (\cf5 "* >>"\cf3 );\b0\cf2  \b else\b0  puts\cf3\b (\cf5 " >>"\cf3 );
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		  \cf3\b \{\b0\cf2 printf\cf3\b (\cf5 "a%d : "\cf3 ,\b0\cf2 j\cf3\b );\b0\cf2  print\cf3\b (\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 		printf\cf3\b (\cf5 "E  :"\cf3 );
\par \b0\cf2 		print\cf3\b (\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 alpha\cf3\b ]);
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	
\par 	\cf1\i //Upto here state table of NFA is entered by user
\par \i0\cf2 	
\par 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf1\i //states without E-moves are un affected in state table
\par \i0\cf2 		\b if\cf3 (\b0\cf2 c\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 0\cf3\b )
\par \b0\cf2 		\cf3\b \{
\par \b0\cf2 			\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 			  \cf3\b \{\b0\cf2  dup\cf3\b (&\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ],\b0\cf2 state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);
\par \b0\cf2 			    sort\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 		\cf3\b \}
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2     \b struct\b0  node \cf3\b *\b0\cf2 pointer\cf3\b ;
\par \b0\cf2 	\cf1\i //Finding E-closures of each state
\par \i0\cf2 	
\par 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2    \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 l\cf3\b ++)\b0\cf2 r\cf3\b [\b0\cf2 l\cf3\b ]=\b0\cf4 1\cf3\b ;
\par \b0\cf2 		\b if\cf3 (\b0\cf2 c\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 1\cf3\b )
\par \b0\cf2 		\cf3\b \{
\par \b0\cf2 			dup\cf3\b (\b0\cf2  \cf3\b &\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ],\b0\cf2  state\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 alpha\cf3\b ]\b0\cf2  \cf3\b );
\par \b0\cf2 			r\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 0\cf3\b ;
\par \b0\cf2 			pointer\cf3\b =\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ];
\par \b0\cf2 			\b while\cf3 (\b0\cf2 pointer\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 			\cf3\b \{
\par \b0\cf2 				k\cf3\b =\b0\cf2 read\cf3\b (\b0\cf2 pointer\cf3\b );
\par \b0\cf2 				\cf1\i //States having a final state in their 
\par \i0\cf2 				\cf1\i //E-closure are also final state
\par \i0\cf2 				\b if\cf3 (\b0\cf2 f\cf3\b [\b0\cf2 k\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 f\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 1\cf3\b ;
\par \b0\cf2 				\b if\cf3 (\b0\cf2 r\cf3\b [\b0\cf2 k\cf3\b ]==\b0\cf4 0\cf3\b )\b0\cf2        
\par 				\cf3\b \{\b0\cf2  pointer\cf3\b =\b0\cf2 pointer\cf3\b ->\b0\cf2 next\cf3\b ;\b0\cf2  \b continue\cf3 ;\b0\cf2  \cf3\b \}
\par \b0\cf2 				\b else
\par \b0 				\cf3\b \{\b0\cf2  k\cf3\b =\b0\cf2 read\cf3\b (\b0\cf2 pointer\cf3\b );
\par \b0\cf2 				  dup\cf3\b (\b0\cf2  \cf3\b &\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ],\b0\cf2  state\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 alpha\cf3\b ]\b0\cf2  \cf3\b );
\par \b0\cf2 				  sort\cf3\b (\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ]);
\par \b0\cf2 				  dupdel\cf3\b (\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ]);
\par \b0\cf2 				  r\cf3\b [\b0\cf2 k\cf3\b ]=\b0\cf4 0\cf3\b ;
\par \b0\cf2 				\cf3\b \}
\par \b0\cf2 			pointer\cf3\b =\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ];
\par \b0\cf2 			\cf3\b \}
\par \b0\cf2 		\cf3\b \}
\par \b0\cf2 		\b else\b0  add\cf3\b (&\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ],\b0\cf2 i\cf3\b );
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	puts\cf3\b (\cf5 "\\n---------------------------------------------------------"\cf3 );
\par \b0\cf2 	printf\cf3\b (\cf5 "%c-closures of states are\\n"\cf3 ,-\b0\cf4 18\cf3\b );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)\{\b0\cf2  printf\cf3\b (\cf5 "S%d ==> "\cf3 ,\b0\cf2 i\cf3\b );\b0\cf2  print\cf3\b (\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 	
\par 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		\cf3\b \{
\par \b0\cf2 			alp\cf3\b =\b0\cf2 NULL\cf3\b ;
\par \b0\cf2 			pointer\cf3\b =\b0\cf2 closure\cf3\b [\b0\cf2 i\cf3\b ];
\par \b0\cf2 			\b while\cf3 (\b0\cf2 pointer\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 			\cf3\b \{
\par \b0\cf2 				k\cf3\b =\b0\cf2 read\cf3\b (\b0\cf2 pointer\cf3\b );
\par \b0\cf2 				dup\cf3\b (&\b0\cf2 alp\cf3\b ,\b0\cf2 state\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 j\cf3\b ]);
\par \b0\cf2 				sort\cf3\b (\b0\cf2 alp\cf3\b );
\par \b0\cf2 				dupdel\cf3\b (\b0\cf2 alp\cf3\b );
\par \b0\cf2 				pointer\cf3\b =\b0\cf2 pointer\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 			\cf3\b \}
\par \b0\cf2 		 pointer\cf3\b =\b0\cf2 alp\cf3\b ;
\par \b0\cf2 		 \b while\cf3 (\b0\cf2 pointer\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 		 \cf3\b \{
\par \b0\cf2 		 	k\cf3\b =\b0\cf2 read\cf3\b (\b0\cf2 pointer\cf3\b );
\par \b0\cf2 		 	dup\cf3\b (&\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ],\b0\cf2 closure\cf3\b [\b0\cf2 k\cf3\b ]);
\par \b0\cf2 		 	sort\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);
\par \b0\cf2 		 	dupdel\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);
\par \b0\cf2 		 	pointer\cf3\b =\b0\cf2 pointer\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		 \cf3\b \}
\par \b0\cf2 	    \cf3\b \}
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	puts\cf3\b (\cf5 "---------------------------------------------------------"\cf3 );
\par \b0\cf2 	\cf1\i //printing Final state table
\par \i0\cf2 	printf\cf3\b (\cf5 "\\nState table of NFA without %c moves is\\n"\cf3 ,-\b0\cf4 18\cf3\b );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "\\n  << S%d"\cf3 ,\b0\cf2 i\cf3\b );
\par \b0\cf2 	  \b if\cf3 (\b0\cf2 f\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 puts\cf3\b (\cf5 "* >>"\cf3 );\b0\cf2  \b else\b0  puts\cf3\b (\cf5 " >>"\cf3 );
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		  \cf3\b \{\b0\cf2 printf\cf3\b (\cf5 "a%d :"\cf3 ,\b0\cf2 j\cf3\b );\b0\cf2  print\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	
\par \cf3\b \}
\par 
\par \b0\cf2 main\cf3\b ()
\par \{
\par \b0\cf2 	\b int\b0  i\cf3\b ,\b0\cf2 j\cf3\b ,\b0\cf2 k\cf3\b ,\b0\cf2 l\cf3\b ,\b0\cf2 num\cf3\b ,\b0\cf2 start\cf3\b ;
\par \b0\cf2     \b char\b0  more\cf3\b ;
\par \b0\cf2 	puts\cf3\b (\cf5 "Welcome to N 2 D FA converter\\n"\cf3 );
\par \b0\cf2 	puts\cf3\b (\cf5 "                   -Achint Chaudhary\\n"\cf3 );
\par \b0\cf2 	getch\cf3\b ();
\par \b0\cf2 	
\par 	printf\cf3\b (\cf5 "Does NFA contains %c moves\\n"\cf3 ,-\b0\cf4 18\cf3\b );
\par \b0\cf2 	more\cf3\b =\b0\cf2 getch\cf3\b ();
\par \b0\cf2 	\b if\cf3 (\b0\cf2 more\cf3\b ==\b0\cf2 'y'\cf3\b )
\par \b0\cf2 	ermvr\cf3\b ();
\par \b0\cf2 	\b else
\par \b0 	\cf3\b \{
\par \b0\cf2 	initialize\cf3\b ();
\par \b0\cf2 	printf\cf3\b (\cf5 "Enter the number of states in NFA "\cf3 );
\par \b0\cf2 	scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 states\cf3\b );
\par \b0\cf2 	printf\cf3\b (\cf5 "Enter the number of alphabets in language "\cf3 );
\par \b0\cf2 	scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 alpha\cf3\b );
\par \b0\cf2 	puts\cf3\b (\cf5 "Enter the enteries in the state table of DFA"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2     printf\cf3\b (\cf5 "\\n  << S%d >> :\\n"\cf3 ,\b0\cf2 i\cf3\b );
\par \b0\cf2 	    	\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2         	\cf3\b \{\b0\cf2  \b if\cf3 (\b0\cf2 j\cf3\b !=\b0\cf4 0\cf3\b )\b0\cf2 puts\cf3\b (\cf5 ""\cf3 );
\par \b0\cf2 			  printf\cf3\b (\cf5 "\\ta%d: \\n"\cf3 ,\b0\cf2 j\cf3\b );
\par \b0\cf2 			 printf\cf3\b (\cf5 "add move <S%d,a%d> ? "\cf3 ,\b0\cf2 i\cf3\b ,\b0\cf2 j\cf3\b );
\par \b0\cf2         	  fflush\cf3\b (\b0\cf2 stdin\cf3\b );\b0\cf2 scanf\cf3\b (\cf5 "%c"\cf3 ,&\b0\cf2 more\cf3\b );
\par \b0\cf2 			  \b while\cf3 (\b0\cf2 more\cf3\b ==\b0\cf2 'y'\cf3\b )
\par \b0\cf2 			  \cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "Enter the state "\cf3 );
\par \b0\cf2 			    scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 num\cf3\b );\b0\cf2  
\par 			    add\cf3\b (&\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ],\b0\cf2 num\cf3\b );
\par \b0\cf2 				printf\cf3\b (\cf5 "add more move <S%d,a%d> ? "\cf3 ,\b0\cf2 i\cf3\b ,\b0\cf2 j\cf3\b );
\par \b0\cf2 				fflush\cf3\b (\b0\cf2 stdin\cf3\b );\b0\cf2 scanf\cf3\b (\cf5 "%c"\cf3 ,&\b0\cf2 more\cf3\b );\}\}
\par \b0\cf2     \cf3\b \}
\par \b0\cf2     puts\cf3\b (\cf5 "Mark each state as final(1) of non-final(0)"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf2  scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 f\cf3\b [\b0\cf2 i\cf3\b ]);
\par \b0\cf2 	
\par 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <=\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		\cf3\b \{\b0\cf2  sort\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  dupdel\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 	
\par 	\cf1\i //printing initial state table
\par \i0\cf2 	puts\cf3\b (\cf5 "\\n---------------------------------------------------------"\cf3 );
\par \b0\cf2 	puts\cf3\b (\cf5 "State table for NFA to be converted to DFA is"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 states\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	\cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "\\n  << S%d"\cf3 ,\b0\cf2 i\cf3\b );
\par \b0\cf2 	  \b if\cf3 (\b0\cf2 f\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 puts\cf3\b (\cf5 "* >>"\cf3 );\b0\cf2  \b else\b0  puts\cf3\b (\cf5 " >>"\cf3 );
\par \b0\cf2 		\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		  \cf3\b \{\b0\cf2 printf\cf3\b (\cf5 "a%d : "\cf3 ,\b0\cf2 j\cf3\b );\b0\cf2  print\cf3\b (\b0\cf2 state2\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);\b0\cf2  \cf3\b \}
\par \b0\cf2 	\cf3\b \}
\par 
\par \b0\cf2 	\cf3\b \}\b0\cf1\i //state table of NFA without E-moves is stored in state2 now
\par \i0\cf2 	   puts\cf3\b (\cf5 "Enter the start state"\cf3 );
\par \b0\cf2 	   scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 start\cf3\b );
\par \b0\cf2 	   puts\cf3\b (\cf5 "\\nPress any key to convert this NFA to DFA\\n"\cf3 );
\par \b0\cf2 	   getch\cf3\b ();
\par \b0\cf2 	\cf1\i //code for conversion to DFA (subset contruction method)
\par \i0\cf2 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2 	  hash\cf3\b [\b0\cf4 0\cf3\b ].\b0\cf2 al\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 0\cf3\b ;
\par \b0\cf2 	  c\cf3\b [\b0\cf4 0\cf3\b ]=\b0\cf4 0\cf3\b ;\b0\cf2    \cf1\i //index 0 is going to be the trap state\\
\par 	so all its entries points to itself
\par \i0\cf2 	add\cf3\b (&\b0\cf2 hash\cf3\b [\b0\cf4 1\cf3\b ].\b0\cf2 next\cf3\b ,\b0\cf2 start\cf3\b );
\par \b0\cf2 	\b if\cf3 (\b0\cf2 f\cf3\b [\b0\cf2 start\cf3\b ]==\b0\cf4 1\cf3\b )\{\b0\cf2 c\cf3\b [\b0\cf4 1\cf3\b ]=\b0\cf4 1\cf3\b ;\}
\par \b0\cf2 	\b else\b0  c\cf3\b [\b0\cf4 1\cf3\b ]=\b0\cf4 0\cf3\b ;
\par \b0\cf2 	current\cf3\b =\b0\cf2 count\cf3\b =\b0\cf4 1\cf3\b ;\b0\cf1\i //working begins from state 1, 0th index for trap state\\
\par 	current proceeds by filling the table completely\\
\par 	count indiactes the number of subsets in the hash table
\par \i0\cf2 	
\par 	\b struct\b0  node \cf3\b *\b0\cf2 pointer\cf3\b ,*\b0\cf2 subset\cf3\b ;
\par \b0\cf2 	
\par 	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 2\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 S\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf2 c\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 0\cf3\b ;\b0\cf2  \cf1\i //upcoming subsets non-final for DFA initially
\par \i0\cf2 	\b while\cf3 (\b0\cf2 current\cf3\b <=\b0\cf2 count\cf3\b )
\par \b0\cf2 	\cf3\b \{
\par \b0\cf2 	\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 	 \cf3\b \{
\par \b0\cf2 	   pointer\cf3\b =\b0\cf2 hash\cf3\b [\b0\cf2 current\cf3\b ].\b0\cf2 next\cf3\b ;\b0\cf1\i // to read the states corresponding to\\
\par 	  state of current index (count)
\par \i0\cf2 	  subset\cf3\b =\b0\cf2 NULL\cf3\b ;\b0\cf2  final\cf3\b =\b0\cf4 0\cf3\b ;
\par \b0\cf2 	  \b while\cf3 (\b0\cf2 pointer\cf3\b !=\b0\cf2 NULL\cf3\b )
\par \b0\cf2 	  \cf3\b \{\b0\cf2    
\par 			k\cf3\b =\b0\cf2 read\cf3\b (\b0\cf2 pointer\cf3\b );
\par \b0\cf2 			dup\cf3\b (&\b0\cf2 subset\cf3\b ,\b0\cf2 state2\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 j\cf3\b ]);
\par \b0\cf2 			sort\cf3\b (\b0\cf2 subset\cf3\b );
\par \b0\cf2 			dupdel\cf3\b (\b0\cf2 subset\cf3\b );
\par \b0\cf2 	        final\cf3\b =\b0\cf2 fcheck\cf3\b (\b0\cf2 subset\cf3\b );
\par \b0\cf2 			pointer\cf3\b =\b0\cf2 pointer\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 	  \cf3\b \}\b0\cf1\i //after end of this loop all states reachable by alphabet 'j'\\
\par 	   corresponding to current state are in subset
\par \i0\cf2 	   	   	   
\par 		 l\cf3\b =\b0\cf2 search\cf3\b (\b0\cf2 subset\cf3\b );
\par \b0\cf2      	\b if\cf3 (\b0\cf2 l\cf3\b ==-\b0\cf4 1\cf3\b )\b0\cf1\i //new subset creation
\par \i0\cf2 			\cf3\b \{
\par \b0\cf2 				count\cf3\b +=\b0\cf4 1\cf3\b ;\b0\cf1\i //index to be used for new subset
\par \i0\cf2 				l\cf3\b =\b0\cf2 count\cf3\b ;
\par \b0\cf2 				dup\cf3\b (&\b0\cf2 hash\cf3\b [\b0\cf2 count\cf3\b ].\b0\cf2 next\cf3\b ,\b0\cf2 subset\cf3\b );
\par \b0\cf2 				sort\cf3\b (\b0\cf2 hash\cf3\b [\b0\cf2 count\cf3\b ].\b0\cf2 next\cf3\b );
\par \b0\cf2 				\b if\cf3 (\b0\cf2 final\cf3\b ==\b0\cf4 1\cf3\b )
\par \b0\cf2 				 c\cf3\b [\b0\cf2 count\cf3\b ]=\b0\cf4 1\cf3\b ;\b0\cf2 		
\par 			\cf3\b \}
\par \b0\cf2 			
\par 		hash\cf3\b [\b0\cf2 current\cf3\b ].\b0\cf2 al\cf3\b [\b0\cf2 j\cf3\b ]=\b0\cf2 l\cf3\b ;
\par \b0\cf2 	 \cf3\b \}
\par \b0\cf2 	current\cf3\b +=\b0\cf4 1\cf3\b ;;
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	
\par 	puts\cf3\b (\cf5 "State table of DFA after subset construction"\cf3 );
\par \b0\cf2 	\b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2       \cf3\b \{
\par \b0\cf2 	    printf\cf3\b (\cf5 "[S%d]"\cf3 ,\b0\cf2 k\cf3\b );
\par \b0\cf2 	    \b if\cf3 (\b0\cf2 c\cf3\b [\b0\cf2 k\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 printf\cf3\b (\cf5 "* : | "\cf3 );
\par \b0\cf2 	    \b else\b0  printf\cf3\b (\cf5 "  : | "\cf3 );
\par \b0\cf2 	   \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2           printf\cf3\b (\cf5 "%d | "\cf3 ,\b0\cf2 hash\cf3\b [\b0\cf2 k\cf3\b ].\b0\cf2 al\cf3\b [\b0\cf2 l\cf3\b ]);\b0\cf2  print\cf3\b (\b0\cf2 hash\cf3\b [\b0\cf2 k\cf3\b ].\b0\cf2 next\cf3\b );
\par \b0\cf2 	  \cf3\b \}
\par \b0\cf2 	
\par 	puts\cf3\b (\cf5 "Do you want to minimize this DFA"\cf3 );
\par \b0\cf2 	more\cf3\b =\b0\cf2 getch\cf3\b ();
\par \b0\cf2 	\b if\cf3 (\b0\cf2 more\cf3\b ==\b0\cf2 'y'\cf3\b )
\par \b0\cf2 	\cf3\b \{
\par \b0\cf2 		i\cf3\b =\b0\cf4 1\cf3\b ;
\par \b0\cf2 		\b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2 		  \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2 		    dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]=\b0\cf2 hash\cf3\b [\b0\cf2 k\cf3\b ].\b0\cf2 al\cf3\b [\b0\cf2 l\cf3\b ];\b0\cf1\i //copying from hash table to dfa table
\par \i0\cf2 		    	    
\par 		\b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 1\cf3\b ;\b0\cf2 k\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2 		  \cf3\b \{\cf2 for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2 		   \b if\cf3 (\b0\cf2 dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]==\b0\cf4 0\cf3\b )
\par \b0\cf2 		   \cf3\b \{\b0\cf2  i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2  \b break\cf3 ;\}\}\b0\cf1\i //i=0 if trap state is reachable
\par \i0\cf2 		trap\cf3\b =\b0\cf2 i\cf3\b ;
\par \b0\cf2 		\b if\cf3 (\b0\cf2 i\cf3\b ==\b0\cf4 1\cf3\b )
\par \b0\cf2 		\cf3\b \{\b0\cf1\i //Our trap state is unreachable
\par \i0\cf2 		   \b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2 		     \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2 		     \cf3\b \{
\par \b0\cf2 		       dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]=\b0\cf2 dfa\cf3\b [\b0\cf2 k\cf3\b +\b0\cf4 1\cf3\b ][\b0\cf2 l\cf3\b ]-\b0\cf4 1\cf3\b ;
\par \b0\cf2 			   c\cf3\b [\b0\cf2 k\cf3\b ]=\b0\cf2 c\cf3\b [\b0\cf2 k\cf3\b +\b0\cf4 1\cf3\b ];\b0\cf2 	
\par 		     \cf3\b \}
\par \b0\cf2 		     count\cf3\b =\b0\cf2 count\cf3\b -\b0\cf4 1\cf3\b ;
\par \b0\cf2 		\cf3\b \}
\par \b0\cf2 		\b else
\par \b0 		\cf3\b \{\b0\cf1\i //Trap state is reachable
\par \i0\cf2 			\b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2 		     \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2 		     \cf3\b \{
\par \b0\cf2 		       \b if\cf3 (\b0\cf2 dfa\cf3\b [\b0\cf2 k\cf3\b +\b0\cf4 1\cf3\b ][\b0\cf2 l\cf3\b ]-\b0\cf4 1\cf3\b !=-\b0\cf4 1\cf3\b )
\par \b0\cf2 			   dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]=\b0\cf2 dfa\cf3\b [\b0\cf2 k\cf3\b +\b0\cf4 1\cf3\b ][\b0\cf2 l\cf3\b ]-\b0\cf4 1\cf3\b ;
\par \b0\cf2 			   \b else
\par \b0 			   dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]=\b0\cf2 count\cf3\b ;
\par \b0\cf2 			   c\cf3\b [\b0\cf2 k\cf3\b ]=\b0\cf2 c\cf3\b [\b0\cf2 k\cf3\b +\b0\cf4 1\cf3\b ];\b0\cf2 	
\par 		     \cf3\b \}
\par \b0\cf2 		     \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2 		       \cf3\b \{\b0\cf2  dfa\cf3\b [\b0\cf2 count\cf3\b ][\b0\cf2 l\cf3\b ]=\b0\cf2 count\cf3\b ;\b0\cf2  c\cf3\b [\b0\cf2 count\cf3\b ]=\b0\cf4 0\cf3\b ;\b0\cf2  \cf3\b \}
\par \b0\cf2 		\cf3\b \}
\par \b0\cf2 				
\par 		\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 count\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf1\i //First pass (final/non-final)
\par \i0\cf2     	\b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf2 i\cf3\b +\b0\cf4 1\cf3\b ;\b0\cf2 j\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2         	\b if\cf3 ((\b0\cf2 c\cf3\b [\b0\cf2 i\cf3\b ]+\b0\cf2 c\cf3\b [\b0\cf2 j\cf3\b ])==\b0\cf4 1\cf3\b )
\par \b0\cf2         	 tab\cf3\b [\b0\cf2 j\cf3\b ][\b0\cf2 i\cf3\b ]=\b0\cf4 1\cf3\b ;
\par \b0\cf2     
\par 		\b do\cf3 \{\b0\cf1\i //Further passes in this do-while loop
\par \i0\cf2     	chk\cf3\b =\b0\cf4 0\cf3\b ;
\par \b0\cf2     	\b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 count\cf3\b ;\b0\cf2 i\cf3\b ++)
\par \b0\cf2     	  \cf3\b \{\cf2 for\cf3 (\b0\cf2 j\cf3\b =\b0\cf2 i\cf3\b +\b0\cf4 1\cf3\b ;\b0\cf2 j\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2     	    \cf3\b \{\cf2 if\cf3 (\b0\cf2 tab\cf3\b [\b0\cf2 j\cf3\b ][\b0\cf2 i\cf3\b ]==\b0\cf4 0\cf3\b )\b0\cf1\i //for empty blocks only
\par \i0\cf2     	    \cf3\b \{\cf2 if\cf3 (\b0\cf2 check\cf3\b (\b0\cf2 i\cf3\b ,\b0\cf2 j\cf3\b ,\b0\cf2 alpha\cf3\b )==\b0\cf4 1\cf3\b )\b0\cf1\i //if get to a filled block
\par \i0\cf2     	    \cf3\b \{\b0\cf2  tab\cf3\b [\b0\cf2 j\cf3\b ][\b0\cf2 i\cf3\b ]=\b0\cf2 pass\cf3\b ;\b0\cf2  chk\cf3\b =\b0\cf4 1\cf3\b ;\}\}\}\}\b0\cf1\i //fill that block by pass
\par \i0\cf2 	   pass\cf3\b +=\b0\cf4 1\cf3\b ;\b0\cf1\i //increment pass as it becomes complete
\par \i0\cf2 	  \cf3\b \}\cf2 while\cf3 (\b0\cf2 chk\cf3\b ==\b0\cf4 1\cf3\b );
\par \b0\cf2 	  
\par 	  puts\cf3\b (\cf5 "---------------------------------------------------------"\cf3 );
\par \b0\cf2       
\par 	  printf\cf3\b (\cf5 "%d passes occur in minimization\\n"\cf3 ,\b0\cf2 pass\cf3\b -\b0\cf4 1\cf3\b );
\par \b0\cf2        puts\cf3\b (\cf5 "\\nFinal computed table is"\cf3 );
\par \b0\cf2       \b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 1\cf3\b ;\b0\cf2 i\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf1\i //Final computed table
\par \i0\cf2     	  \cf3\b \{\b0\cf2  printf\cf3\b (\cf5 "[%d] "\cf3 ,\b0\cf2 i\cf3\b );
\par \b0\cf2 		    \b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 i\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		      printf\cf3\b (\cf5 " %d "\cf3 ,\b0\cf2 tab\cf3\b [\b0\cf2 i\cf3\b ][\b0\cf2 j\cf3\b ]);
\par \b0\cf2           puts\cf3\b (\cf5 ""\cf3 );\}
\par \b0\cf2           printf\cf3\b (\cf5 "    "\cf3 );
\par \b0\cf2           \b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 j\cf3\b <\b0\cf2 count\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2 		      printf\cf3\b (\cf5 "[%d]"\cf3 ,\b0\cf2 j\cf3\b );
\par \b0\cf2 	  
\par 	   puts\cf3\b (\cf5 "\\n---------------------------------------------------------"\cf3 );
\par \b0\cf2       \b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf2 r\cf3\b [\b0\cf2 i\cf3\b ]=\b0\cf4 1\cf3\b ;
\par \b0\cf2 	  \b for\cf3 (\b0\cf2 i\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 i\cf3\b <\b0\cf2 count\cf3\b ;\b0\cf2 i\cf3\b ++)\b0\cf1\i //modifying state table to minimize it
\par \i0\cf2       \b for\cf3 (\b0\cf2 j\cf3\b =\b0\cf2 i\cf3\b +\b0\cf4 1\cf3\b ;\b0\cf2 j\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 j\cf3\b ++)
\par \b0\cf2        \cf3\b \{\cf2 if\cf3 (\b0\cf2 r\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 1\cf3\b )
\par \b0\cf2        	\cf3\b \{\cf2 if\cf3 (\b0\cf2 tab\cf3\b [\b0\cf2 j\cf3\b ][\b0\cf2 i\cf3\b ]==\b0\cf4 0\cf3\b )
\par \b0\cf2        	 \cf3\b \{\b0\cf2   r\cf3\b [\b0\cf2 j\cf3\b ]=\b0\cf4 0\cf3\b ;\b0\cf1\i //make that state unreadable
\par \i0\cf2        	    r_modify\cf3\b =\b0\cf4 1\cf3\b ;
\par \b0\cf2        		\b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2        		  \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2        		   \cf3\b \{\b0\cf2  \b if\cf3 (\b0\cf2 dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]==\b0\cf2 j\cf3\b )
\par \b0\cf2        		      dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]=\b0\cf2 i\cf3\b ;\b0\cf1\i //modify higher states of same block
\par \i0\cf2 			     \b if\cf3 (\b0\cf2 c\cf3\b [\b0\cf2 j\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2     \cf1\i //with the smallest state
\par \i0\cf2 			      c\cf3\b [\b0\cf2 i\cf3\b ]==\b0\cf4 1\cf3\b ;\}
\par \b0\cf2        	 \cf3\b \}\b0\cf2  \cf3\b \}
\par \b0\cf2        	 \b else\b0  \b break\cf3 ;\b0\cf2  \cf3\b \}
\par 
\par \b0\cf2        	 \b if\cf3 (\b0\cf2 r_modify\cf3\b ==\b0\cf4 0\cf2  \cf3\b &&\b0\cf2  trap\cf3\b ==\b0\cf4 0\cf2  \cf3\b )
\par \b0\cf2 	   \cf3\b \{\b0\cf2  puts\cf3\b (\cf5 "\\nMachine is already minimized"\cf3 );
\par \b0\cf2 	     puts\cf3\b (\cf5 "S0 is trap state while S1 is starting state"\cf3 );\b0\cf2  
\par 	     puts\cf3\b (\cf5 "\\nThanks for using my code"\cf3 );\b0\cf2  getch\cf3\b ();\b0\cf2  \b return\b0  \cf4 0\cf3\b ;\b0\cf2  \cf3\b \}
\par \b0\cf2     
\par 	puts\cf3\b (\cf5 "\\nFinal State table of Minimized DFA is"\cf3 );
\par \b0\cf2     \b for\cf3 (\b0\cf2 k\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 k\cf3\b <=\b0\cf2 count\cf3\b ;\b0\cf2 k\cf3\b ++)
\par \b0\cf2       \cf3\b \{\cf2 if\cf3 (\b0\cf2 r\cf3\b [\b0\cf2 k\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2  
\par 	   \cf3\b \{\b0\cf2 printf\cf3\b (\cf5 "[S%d]"\cf3 ,\b0\cf2 k\cf3\b );
\par \b0\cf2 	    \b if\cf3 (\b0\cf2 c\cf3\b [\b0\cf2 k\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 printf\cf3\b (\cf5 "* : | "\cf3 );
\par \b0\cf2 	    \b else\b0  printf\cf3\b (\cf5 "  : | "\cf3 );
\par \b0\cf2 	   \b for\cf3 (\b0\cf2 l\cf3\b =\b0\cf4 0\cf3\b ;\b0\cf2 l\cf3\b <\b0\cf2 alpha\cf3\b ;\b0\cf2 l\cf3\b ++)
\par \b0\cf2           printf\cf3\b (\cf5 "%d | "\cf3 ,\b0\cf2 dfa\cf3\b [\b0\cf2 k\cf3\b ][\b0\cf2 l\cf3\b ]);
\par \b0\cf2        \cf3\b \}
\par \b0\cf2        \b if\cf3 (\b0\cf2 r\cf3\b [\b0\cf2 k\cf3\b ]==\b0\cf4 1\cf3\b )\b0\cf2 puts\cf3\b (\cf5 ""\cf3 );
\par \b0\cf2 	  \cf3\b \}
\par \b0\cf2 	   puts\cf3\b (\cf5 "S0 is starting state"\cf3 );
\par \b0\cf2 	   		
\par 	\cf3\b \}\b0\cf1\i //minimization ends here
\par \i0\cf2 	  puts\cf3\b (\cf5 "\\nThanks for using my code"\cf3 );
\par \b0\cf2 	   getch\cf3\b ();
\par \}
\par }